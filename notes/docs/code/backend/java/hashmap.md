---
title: HashMap面经常见问题
icon: file
order: 
date: ""
category:
  - Java
tags:
  - 面经
---
## 

**为什么容量必须是 2 的次幂**

1. **索引计算高效**：通过 hash & (capacity - 1) 快速计算索引，替代取模操作。在计算机中，位运算的速度要远高于取余运算，因为计算机本质上就是二进制嘛。

2. **扩容高效**：容量翻倍时，仅通过简单的位运算 hash & (oldCap) 即可判断元素位置，无需重新计算所有索引。

3. **冲突率低**：2 幂次⽅刚好是偶数，偶数-1 是奇数，奇数的⼆进制最后⼀位是 1，也就保证了 hash &(length-1) 的最后⼀位可能为 0，也可能为 1（取决于 hash 的值），这样可以保证哈希值的均匀分布。

4. **实现简单**：避免复杂的对齐计算。


链表树化的条件由两部分组成：

1. 插入时链表长度达到 >= 8，调用 treeifyBin。

2. treeifyBin 方法中，数组长度必须 >= 64 才真正树化，否则会优先扩容。